"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IconIcns = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var packbits = _interopRequireWildcard(require("@fiahfy/packbits"));

var _icon = require("../icon");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// For compatability for CommonJS and ESM.
const packbitsEncode = packbits.encode || packbits.default.encode;
const typeArgb = ['ic04', 'ic05'];
const typePng = ['icp4', 'icp5', 'icp6', 'ic07', 'ic08', 'ic09', 'ic10', 'ic11', 'ic12', 'ic13', 'ic14'];
const typeIcon24Bit = ['is32', 'il32', 'ih32', 'it32'];
const typeMask8Bit = ['s8mk', 'l8mk', 'h8mk', 't8mk'];
/**
 * Icon entry.
 */

/**
 * IconIcns constructor.
 */
class IconIcns extends _icon.Icon {
  /**
   * Option to include TOC tag (table of contents) in encode.
   */

  /**
   * List of icon entries.
   */

  /**
   * Types that are ARGB.
   */

  /**
   * Types that are PNG.
   */

  /**
   * Types that are icon 24-bit.
   */

  /**
   * Types that are mask 8-bit.
   */
  constructor() {
    super();
    (0, _defineProperty2.default)(this, "toc", false);
    (0, _defineProperty2.default)(this, "entries", []);
    (0, _defineProperty2.default)(this, "_typeArgb", new Set(typeArgb));
    (0, _defineProperty2.default)(this, "_typePng", new Set(typePng));
    (0, _defineProperty2.default)(this, "_typeIcon24Bit", new Set(typeIcon24Bit));
    (0, _defineProperty2.default)(this, "_typeMask8Bit", new Set(typeMask8Bit));
  }
  /**
   * Add an icon from PNG data.
   *
   * @param data PNG data.
   * @param types Types to encode as.
   * @param raw Use raw PNG data without re-encoding for the PNG types.
   */


  addFromPng(data, types, raw = false) {
    if (!raw) {
      this.addFromRgba(this._decodePngToRgba(data), types);
      return;
    }

    let rgba = null;

    for (const type of types) {
      if (this._typePng.has(type)) {
        this.entries.push({
          type,
          data: Buffer.concat([data], data.length)
        });
        continue;
      }

      rgba || (rgba = this._decodePngToRgba(data));
      this.addFromRgba(rgba, [type]);
    }
  }
  /**
   * Add an icon from RGBA image data.
   *
   * @param imageData RGBA image data.
   * @param types Types to encode as.
   */


  addFromRgba(imageData, types) {
    for (const type of types) {
      this._addFromRgbaType(imageData, type);
    }
  }
  /**
   * Encode icon.
   *
   * @returns Encoded icon.
   */


  encode() {
    const {
      toc
    } = this;
    const head = Buffer.alloc(8);
    head.write('icns', 0);
    let size = 8;
    let tocSize = 8;
    const tocHead = toc ? Buffer.from('TOC ----') : null;
    const tocs = tocHead ? [tocHead] : [];
    const images = [];

    for (const {
      type,
      data
    } of this.entries) {
      const tagType = Buffer.alloc(4);
      tagType.write(type, 0);
      const tagSize = Buffer.alloc(4);
      const tagSizeValue = data.length + 8;
      tagSize.writeUInt32BE(tagSizeValue, 0);

      if (toc) {
        tocs.push(tagType, tagSize);
        tocSize += 8;
        size += 8;
      }

      images.push(tagType, tagSize, data);
      size += tagSizeValue;
    }

    if (tocHead) {
      tocHead.writeUInt32BE(tocSize, 4);
      size += 8;
    }

    head.writeUInt32BE(size, 4);
    return Buffer.concat([head, ...tocs, ...images], size);
  }
  /**
   * Add an icon from RGBA image data, individual type.
   *
   * @param imageData RGBA image data.
   * @param type Type to encode as.
   */


  _addFromRgbaType(imageData, type) {
    if (this._typeArgb.has(type)) {
      this.entries.push({
        type,
        data: this._encodeRgbaToTypeArgb(imageData, type)
      });
      return;
    }

    if (this._typePng.has(type)) {
      this.entries.push({
        type,
        data: this._encodeRgbaToTypePng(imageData, type)
      });
      return;
    }

    if (this._typeIcon24Bit.has(type)) {
      this.entries.push({
        type,
        data: this._encodeRgbaToTypeIcon24Bit(imageData, type)
      });
      return;
    }

    if (this._typeMask8Bit.has(type)) {
      this.entries.push({
        type,
        data: this._encodeRgbaToTypeMask8Bit(imageData, type)
      });
      return;
    }

    throw new Error(`Unknown type: ${type}`);
  }
  /**
   * Encode RGBA image data to ARGB.
   *
   * @param imageData RGBA image data.
   * @param _type Icon type.
   * @returns Encoded data.
   */


  _encodeRgbaToTypeArgb(imageData, _type) {
    // The compressed data always has an ARGB header.
    return this._encodeRgbaToPackBits(imageData, true, Buffer.from('ARGB', 'ascii'));
  }
  /**
   * Encode RGBA image data to PNG.
   *
   * @param imageData RGBA image data.
   * @param _type Icon type.
   * @returns Encoded data.
   */


  _encodeRgbaToTypePng(imageData, _type) {
    return this._encodeRgbaToPng(imageData);
  }
  /**
   * Encode RGBA image data to icon 24-bit.
   *
   * @param imageData RGBA image data.
   * @param type Icon type.
   * @returns Encoded data.
   */


  _encodeRgbaToTypeIcon24Bit(imageData, type) {
    // The 'it32' type has 4 null byte header.
    return this._encodeRgbaToPackBits(imageData, false, type === 'it32' ? Buffer.alloc(4) : null);
  }
  /**
   * Encode RGBA image data to mask 8-bit.
   *
   * @param imageData RGBA image data.
   * @param _type Icon type.
   * @returns Encoded data.
   */


  _encodeRgbaToTypeMask8Bit(imageData, _type) {
    return this._encodeRgbaChannel(imageData, 3);
  }
  /**
   * Encode RGBA image data to packbits.
   *
   * @param imageData RGBA image data.
   * @param alpha Incldue the alpha channel.
   * @param header Header to prepend to the output.
   * @returns Encoded data.
   */


  _encodeRgbaToPackBits(imageData, alpha, header = null) {
    const pieces = header ? [header] : [];

    if (alpha) {
      // A:
      pieces.push(this._encodePackBitsIcns(this._encodeRgbaChannel(imageData, 3)));
    } // RGB:


    pieces.push(this._encodePackBitsIcns(this._encodeRgbaChannel(imageData, 0)), this._encodePackBitsIcns(this._encodeRgbaChannel(imageData, 1)), this._encodePackBitsIcns(this._encodeRgbaChannel(imageData, 2)));
    return Buffer.concat(pieces);
  }
  /**
   * Encode channel from RGBA image data.
   *
   * @param imageData RGBA image data.
   * @param index Channel index (R=0, B=1, G=2, A=3).
   * @returns Encoded data.
   */


  _encodeRgbaChannel(imageData, index) {
    const {
      data
    } = imageData;
    const size = data.length;
    const encoded = Buffer.alloc(size / 4);

    for (let i = index, j = 0; i < size; i += 4) {
      encoded.writeUInt8(data[i], j++);
    }

    return encoded;
  }
  /**
   * Encode data using PackBits ICNS compression.
   *
   * @param data Data to be compressed.
   * @returns Compressed data.
   */


  _encodePackBitsIcns(data) {
    return packbitsEncode(data, {
      format: 'icns'
    });
  }

}

exports.IconIcns = IconIcns;
//# sourceMappingURL=icns.js.map
