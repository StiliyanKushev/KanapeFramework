/// <reference types="node" />
import { IImageData } from '../types';
import { Icon } from '../icon';
/**
 * Icon entry.
 */
export interface IIconIcoEntry {
    /**
     * Icon width.
     */
    readonly width: number;
    /**
     * Icon height.
     */
    readonly height: number;
    /**
     * Icon data.
     */
    readonly data: Readonly<Buffer>;
}
/**
 * IconIco constructor.
 */
export declare class IconIco extends Icon {
    /**
     * List of icon entries.
     */
    entries: IIconIcoEntry[];
    constructor();
    /**
     * Add an icon from PNG data.
     *
     * @param data PNG data.
     * @param png Encode entry as PNG.
     * @param raw Use raw PNG data without re-encoding, if using PNG format.
     */
    addFromPng(data: Readonly<Buffer>, png?: boolean | null, raw?: boolean): void;
    /**
     * Add an icon from RGBA image data.
     *
     * @param imageData RGBA image data.
     * @param png Encode entry as PNG.
     */
    addFromRgba(imageData: Readonly<IImageData>, png?: boolean | null): void;
    /**
     * Encode icon.
     *
     * @returns Encoded icon.
     */
    encode(): Buffer;
    /**
     * Encode icon directory header.
     *
     * @param count Entry count.
     * @returns Encoded header.
     */
    protected _encodeIcoDir(count: number): Buffer;
    /**
     * Encode icon directory entry.
     *
     * @param entry Icon entry.
     * @param offset File offset.
     * @returns Encoded entry.
     */
    protected _encodeIcoDirEntry(entry: Readonly<IIconIcoEntry>, offset: number): Buffer;
    /**
     * Encode RGBA image to BMP data.
     *
     * @param imageData Image data.
     * @returns BMP data.
     */
    protected _encodeRgbaToBmp(imageData: Readonly<IImageData>): Buffer;
    /**
     * Check if height requires legacy bitmap for compatiblity.
     *
     * @param width Image width.
     * @param height Image height.
     * @returns Returns true if requires legacy bitmap.
     */
    protected _sizeRequiresLegacyBitmap(width: number, height: number): boolean;
}
