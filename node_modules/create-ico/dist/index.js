"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createIco = void 0;
const icon_encoder_1 = require("@shockpkg/icon-encoder");
const sharp_1 = __importDefault(require("sharp"));
const imagemin_1 = __importDefault(require("imagemin"));
const imagemin_pngquant_1 = __importDefault(require("imagemin-pngquant"));
const fs_1 = require("fs");
const DEFAULT_OPTIONS = {
    sizes: [16, 32],
    pngquant: {
        speed: 1,
        strip: true
    }
};
async function createIco(input, outputOrOptions, options) {
    // Handle overloads
    let output;
    if (typeof outputOrOptions == 'string') {
        output = outputOrOptions;
    }
    else {
        options = outputOrOptions;
    }
    // Apply default options
    options = options ? { ...DEFAULT_OPTIONS, ...options } : DEFAULT_OPTIONS;
    // Check sizes
    if (options.sizes.some(s => s < 1 || s > 256)) {
        throw new Error('Icon sizes must be between 1 and 256.');
    }
    // Create png for each icon size
    // For loop as sharp seems to hang sometimes when doing composites in parallel
    let inputPipeline = sharp_1.default(input);
    let pngs = [];
    for (let size of options.sizes) {
        let pipeline = options.sizes.length > 1 ? inputPipeline.clone() : inputPipeline;
        // Resize
        pipeline = pipeline
            .resize({
            width: size,
            height: size,
            fit: 'contain',
            background: { r: 255, g: 255, b: 255, alpha: 0 }
        });
        // Apply mask
        if (options.shape == 'circle') {
            let radius = size / 2;
            pipeline = pipeline
                .composite([{
                    input: Buffer.from(`<svg><circle cx="${radius}" cy="${radius}" r="${radius}" /></svg>`),
                    blend: 'dest-in'
                }]);
        }
        // Write png
        let png = await pipeline.png().toBuffer();
        // Optimize
        pngs.push(await imagemin_1.default.buffer(png, {
            plugins: [
                imagemin_pngquant_1.default(options.pngquant)
            ]
        }));
    }
    // Create ico
    let ico = new icon_encoder_1.IconIco();
    for (let png of pngs) {
        ico.addFromPng(png, true);
    }
    // Save or return buffer
    if (output === undefined) {
        return ico.encode();
    }
    else {
        await fs_1.promises.writeFile(output, ico.encode());
    }
}
exports.createIco = createIco;
